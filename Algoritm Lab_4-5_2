//двусвязный список

#include <iostream>

using namespace  std;


class my_list {                                       //Список MyList
	int x, count_;
	my_list* head_, * tail_, * next_, * prev_;
public:
	my_list() :count_(0), head_(nullptr), tail_(nullptr) {}     //Инициализация с помощью конструктора по умолчанию
	void add(int);
	void show();
	void del(int);                                  //Функция принимает целочисленный параметр, обозначающий номер удаляемого элемента
	~my_list();
};

/*ДОБАВЛЕНИЕ ЭЛЕМЕНТА В СПИСОК*/
void my_list::add(int x) {
	my_list* temp = new my_list;
	temp->x = x;
	temp->next_ = nullptr;
	count_++;
	if (!head_) {
		temp->prev_ = nullptr;
		head_ = temp;
		tail_ = head_;
	}
	else {
		temp->prev_ = tail_;                  //Указываем, что предыдущим элементом списка относительно добавленного, будет последний элемент существующего списка
		tail_->next_ = temp;                  //Следующий за последним существующим это непосредственно сейчас добавляемый элемент списка
		tail_ = temp;                        //После того как указали что есть настоящий и что предыдущий, объявляем, что последний существующий это только что добавленный элемент
	}
}

/*ПОКАЗЫВАЕТ СПИСОК НА ЭКРАНЕ*/
void my_list::show() {
	my_list* t = head_;
	while (t) {
		cout << t->x << " ";
		t = t->next_;
	}
	cout << "\n\n";
}


/*ФУНКЦИЯ УДАЛЕНИЯ КОНКРЕТНОГО ЭЛЕМЕНТА ДВУСВЯЗНОГО СПИСКА*/
void my_list::del(int x) {
	//Если удаляем первый элемент, то могут быть такие варианты
	//В списке есть только первый, в списке есть несколько элементов
	//Поэтому разбиваем логику выполнения
	if ((x == 1) and (head_->next_)) {                     //Если удаляем первый, но есть и другие, то
		my_list* temp = head_;	                        //Указываем, что нам нужно начало списка
		head_ = head_->next_;	                            //Сдвигаем начало на следующий за началом элемент
		head_->prev_ = nullptr;	                            //Делаем так, чтоб предыдущий началу элемент был пустым
		delete temp;		                            //Удаляем удаляемое начало
		count_--;		                                //Обязательно уменьшаем счетчик
		return;		                                //И выходим из функции
	}
	else if ((x == 1) and (head_ == tail_)) {            //Если удаляем первый, но в списке только 1 элемент

		head_->next_ = nullptr;	                            //обнуляем все что нужно
		head_ = nullptr;
		delete head_;		                            //Удаляем указатель на начало
		count_ = 0;		                                //Обязательно обозначаем, что в списке ноль элементов
		return;			                                //и выходим из функции
	}

	//Также может быть, что удаляемый элемент является последним элементом списка
	if (x == count_) {
		my_list* temp = tail_;	                            //Указываем, что нам нужен хвост
		tail_ = tail_->prev_;	                                //Отодвигаем хвост немного назад
		tail_->next_ = nullptr;	                                //Обозначаем, что впереди за хвостом пусто
		delete temp;	                                    //Очищаем память от бывшего хвоста
		count_--;		                                    //Обязательно уменьшаем счетчик элементов
		return;		                                    //И выходим из функции
	}

	//Если же удаляемый элемент лежит где-то в середине списка, то тогда его можно удалить

	my_list* temp = head_, * temp2;                        //temp-Удаляемый элемент, temp2 нужен, чтобы не потерять данные

	//cout<<count_<<"\n";
	for (int i = 0; i < x - 1; i++) temp = temp->next_;  //Идем к адресу удаляемого элемента

	temp2 = temp;	                                //Временно запоминаем адрес удаляемого элемента
	temp2->prev_->next_ = temp->next_;	            //Записываем данные, что следующий за перед сейчас удаляемым элементом - это следующий от удаляемого
	temp2->next_->prev_ = temp->prev_;               //а предыдущий для следующего - это предыдущий для удаляемого
	delete temp;                               //теперь смело можно освободить память, удалив адрес на начало удаляемого элемента
	count_--;                                         //Обязательно уменьшаем число элементов в списке.
}


/*ДЕСТРУКТОР ДЛЯ КОРРЕКТНОГО ВЫСВОБОЖДЕНИЯ ПАМЯТИ*/
my_list::~my_list() {
	//   cout<<"\nDELETES\n";
	while (head_) {
		// cout<<"Del is: "<<Head->x<<"  ";
		tail_ = head_->next_;
		delete head_;
		head_ = tail_;
	}
}

int main()
{
	system("CLS");

	my_list l;
	l.add(10);
	l.add(20);
	l.add(30);
	l.add(40);
	l.add(50);
	l.show();
	l.del(3);
	l.show();
	l.del(2);
	l.show();

	system("PAUSE");
	return 0;
}
